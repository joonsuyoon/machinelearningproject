# -*- coding: utf-8 -*-
"""최종 후보지 점수화 및 상위 30개 선정.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13qBvE_JVsI48WDh9o5JO8Wt8nzKZOeTi
"""

import pandas as pd
from geopy.distance import geodesic
from google.colab import files
from sklearn.preprocessing import MinMaxScaler

# 파일 업로드
uploaded = files.upload()

# 데이터 불러오기
candidates = pd.read_csv("통합후보지(100m).csv")
biz = pd.read_csv("상권별 통합정보.csv")

# 상권 유동인구/매출 정규화
scaler = MinMaxScaler()
biz[["norm_h", "norm_w"]] = scaler.fit_transform(biz[["총_유동인구_수", "당월_매출_금액"]])
biz["score"] = 0.7 * biz["norm_h"] + 0.3 * biz["norm_w"]

# 각 후보지에 대해 가장 가까운 상권 찾기
def find_nearest_score(lat, lng):
    min_dist = float("inf")
    nearest_score = 0
    for _, row in biz.iterrows():
        dist = geodesic((lat, lng), (row["위도"], row["경도"])).meters
        if dist < min_dist:
            min_dist = dist
            nearest_score = row["score"]
    return nearest_score

# 점수 계산
candidates["score"] = candidates.apply(lambda row: find_nearest_score(row["위도"], row["경도"]), axis=1)

# 상위 30개 추출
top30 = candidates.sort_values("score", ascending=False).head(30)

# 저장 및 다운로드
top30.to_csv("final_top30.csv", index=False)
files.download("fianl_top30.csv")

"""Greedy 방식 (100m 중복 제거)"""

selected = []
radius = 100

remaining = candidates.sort_values("score", ascending=False).copy()

while len(selected) < 30 and not remaining.empty:
    top = remaining.iloc[0]
    selected.append(top)
    # 100m 이내 제거
    remaining = remaining[remaining.apply(
        lambda r: geodesic((r["위도"], r["경도"]), (top["위도"], top["경도"])).meters > radius,
        axis=1
    )]

greedy_df = pd.DataFrame(selected)
greedy_df.to_csv("greedy_top30.csv", index=False)
files.download("greedy_top30.csv")

"""분산 점수 보정 방식 (최종점수 = 기본점수 × (1 + 분산도))"""

# 거리 행렬 계산
coords = candidates[["위도", "경도"]].to_numpy()
dist_matrix = np.zeros((len(coords), len(coords)))

for i in range(len(coords)):
    for j in range(len(coords)):
        if i != j:
            dist_matrix[i, j] = geodesic(coords[i], coords[j]).meters

# 평균 거리 계산 → 분산도
mean_dist = dist_matrix.mean(axis=1)
norm_dispersion = (mean_dist - mean_dist.min()) / (mean_dist.max() - mean_dist.min())

candidates["dispersion"] = norm_dispersion
candidates["final_score"] = candidates["score"] * (1 + candidates["dispersion"])

# 상위 30개 선택
spatial_df = candidates.sort_values("final_score", ascending=False).head(30)
spatial_df.to_csv("spatial_score_top30.csv", index=False)
files.download("spatial_score_top30.csv")